 ##### 线程同步原理
```
参考链接http://www.hollischuang.com/archives/1876
   
栈        线程独立    只存储基本类型与对象引用

堆        线程共享    只存储对象
方法区    线程共享    只存储类的静态变量(只包括基本类型与对象引用)


为了协调对象多线程下访问状态,虚拟机给每个对象与类都分配了一个特权锁,
同一时刻,只有一个线程可以拥有这个对象或类的使用权力.如果一个线程想获
得某个对象或类的使用权,需要先向虚拟机申请.可能会很快或很慢获得锁,也
可能永远不会获得锁,当线程不再需要锁的时候，他再把锁还给虚拟机。这时虚
拟机就可以再把锁分配给其他申请锁的线程。

注:类锁也是基于对象实现的,因为虚拟机加载该类的时候会给这个类生成一个
java.lang.Class对象,即类对象.当你对一个类加锁时,其实是锁住了这个类的
Class对象

监视器
虚拟机通过监视器确保同一时间只有一个线程在执行一段代码,当线程执行到监视器
监视的代码块第一条指令时,线程必须获取被引用对象的锁.获取锁之前,线程是无法
执行这段代码的,一旦获得锁,线程遍可以进入"被保护"的代码开始执行.当线程离开
代码块时,会释放所关联对象的锁.

多次加锁
同一线程可以对同一对象进行多次枷锁,每个对象维护着一个被锁次数的计数器
未被锁定的对象的该计数器为0,当一个线程获得锁后,计数器自增变为1
当同一线程再次获得该对象的锁的时候,计数器再次自增.当同一线程释放
锁的时候,计数器再自减.当计数器为0的时候,锁被释放,其他线程
便可以获得锁.   
```
 
 ##### 对象头（Header）
Mark world
    用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，
    这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit
class 指针
    对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例.
length(数组独有)
    如果对象是一个数组, 那在对象头中有一块数据用于记录数组长度.
##### 实例数据（Instance Data）
##### 对齐填充（Padding）
Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。在不同的锁状态下存储的内容不同，在32位JVM中如图所示：

![Image text](https://gitee.com/weixin54321a/ApiStarter/raw/master/resource/markworld.png)

Mark World解释(说明: 此处摘自https://blog.csdn.net/lkforce/article/details/81128115 )

Mark Word记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。

其中无锁和偏向锁的锁标志位都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态。

JDK1.6以后的版本在处理同步锁时存在锁升级的概念，JVM对于同步锁的处理是从偏向锁开始的，随着竞争越来越激烈，处理方式从偏向锁升级到轻量级锁，最终升级到重量级锁。

 

JVM一般是这样使用锁和Mark Word的：

1. 当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。

2. 当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。

3. 当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。

4. 当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。
如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。

5. 偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，
同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，
可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。

6. 轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。

7. 自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。
    